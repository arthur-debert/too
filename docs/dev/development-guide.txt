                Development Guide

This guide provides comprehensive information for too contributors,
covering quick start, conventions, and architecture.


1. Quick Start

    Prerequisites:
    
        • Go 1.23 or later
        • Git
        • A Unix-like environment (macOS, Linux, WSL)

    Initial Setup:
    
        1. Clone and enter the repository:
        
            -- bash
            git clone https://github.com/arthur-debert/too.git
            cd too
            --

        2. Source the environment variables if not using direnv:
        
            -- bash
            source .envrc
            --

        3. Install pre-commit hooks (MANDATORY):
        
            -- bash
            scripts/pre-commit install
            --

        4. Run tests to verify setup:
        
            -- bash
            scripts/test
            --

    Essential Commands:
    
        • scripts/build - Build the CLI binary
        • scripts/test - Run all tests with race detection
        • scripts/lint - Run golangci-lint
        • scripts/test-with-cov - Generate coverage report
        • scripts/pre-commit - Run all pre-commit checks

    Development Workflow:
    
        1. Create a feature branch:
            • For GitHub issues: gh issue develop -c <issue-id>
            • Otherwise: git checkout -b feature/description

        2. Write tests first (TDD encouraged)

        3. Implement with proper logging

        4. Run tests and lint before committing

        5. Pre-commit hooks will catch any issues

        6. Create PR with issue reference for auto-close


2. Architecture Overview

    too follows a strict separation of concerns:

    CLI Layer (cmd/):
    
        • Thin layer using Cobra framework
        • Only handles argument parsing and validation
        • Help text and user messages
        • Output formatting via pkg/too/output
        • NO business logic

    Business Logic (pkg/too/):
    
        • Core command implementations
        • Pure Go functions with typed parameters
        • Returns structured data, never prints
        • Uses nanostore for all storage operations

    Storage Layer (pkg/too/store/):
    
        • NanoStoreAdapter wraps nanostore library
        • Provides SQLite-based persistent storage
        • Handles semi-stable ID generation
        • Manages canonical namespaces (pending/completed)

    Data Flow:
    
        1. User runs command: too add "todo text" 
        2. cmd/too/add.go parses arguments and flags
        3. Calls too.Add() which uses NanoStoreAdapter
        4. Nanostore manages IDs and persistence
        5. Business logic processes the operation
        6. Results returned with position paths for display
        7. Renderer formats output based on --format flag


3. Storage Architecture

    Nanostore Integration:
    
        • SQLite database for reliable storage
        • Semi-stable IDs with canonical namespaces
        • Pending items: consecutive numbering (1, 2, 3...)
        • Completed items: 'c' namespace (1.c1, 1.c2...)

    Position Path System:
    
        • User-facing IDs calculated dynamically
        • Remain stable within namespace
        • Change when structural operations occur
        • Hierarchical support (1.2, 1.2.3)

    Storage Operations:
    
        • All operations go through NanoStoreAdapter
        • Atomic transactions with SQLite
        • Efficient bulk operations (e.g., DeleteCompleted)


4. Development Standards

    Code Organization:
    
        • Package names match directory names
        • One concern per package
        • Clear public API surface
        • Internal packages for implementation details

    Function Design:
    
        • Accept parameters, return results
        • No side effects beyond stated purpose
        • Clear error messages with context
        • Consistent parameter ordering

    Error Handling:
    
        Standard Go error handling:
        
            if err != nil {
                return fmt.Errorf("context: %w", err)
            }

        Always wrap errors with context for debugging.

    Testing Requirements:
    
        • Unit tests for all business logic
        • Table-driven tests for multiple scenarios
        • Use testutil helpers for common operations
        • Test both success and error paths
        • Integration tests in scripts/test


5. Logging Guidelines

    Severity Levels:
    
        • ERROR: Operation failures requiring user action
        • WARN: Degraded functionality but operation continues
        • INFO: High-level operation progress
        • DEBUG (-v): Detailed operation steps
        • TRACE (-vv): Low-level execution details

    Structured Logging:
    
        Use zerolog with consistent field names:
        
            log.Debug().
                Str("todo_id", id).
                Str("status", "completed").
                Msg("Todo status updated")

    Performance:
    
        • Log sampling for high-frequency operations
        • Conditional logging based on verbosity
        • No logging in tight loops


6. Testing Patterns

    Test Organization:
    
        • Tests next to code (*_test.go)
        • Test data in testdata/ directories
        • Shared test utilities in testutil/

    Nanostore Testing:
    
        // Create test store
        adapter, dbPath := testutil.CreateTestStore(t)
        defer adapter.Close()
        
        // Add test data
        todo, err := adapter.Add("Test todo", nil)
        require.NoError(t, err)
        
        // Test operations
        err = adapter.Complete(todo.PositionPath)
        assert.NoError(t, err)

    Table-Driven Tests:
    
        tests := []struct {
            name     string
            input    string
            expected string
            wantErr  bool
        }{
            {"valid", "1", "1", false},
            {"invalid", "x", "", true},
        }
        
        for _, tt := range tests {
            t.Run(tt.name, func(t *testing.T) {
                // Test implementation
            })
        }

    E2E Testing:
    
        Comprehensive end-to-end tests in live-tests/e2e/ using Bats.
        See live-tests/e2e/README.txt for details on running and writing
        e2e tests. Key points:
        
        • Run all: ./live-tests/e2e/run-tests.sh
        • Run one file: bats live-tests/e2e/suite/01-creation.bats
        • Use JSON format for reliable assertions
        • Tests cover all major CLI operations


7. Data Persistence

    Database Format:
    
        • SQLite database file (.todos.db)
        • Managed entirely by nanostore
        • Automatic schema creation
        • Transaction support

    File Locations:
    
        • Default: ~/.todos.db
        • Override: TODO_DB_PATH environment variable
        • Local: .todos.db in current/parent directories

    Concurrency:
    
        • SQLite handles concurrent access
        • Each command creates new connection
        • No long-running processes


8. Command Patterns

    Adding Features:
    
        1. Define command in cmd/too/
        2. Create Options struct in pkg/too/
        3. Implement business logic function
        4. Add tests for all scenarios
        5. Update help text and documentation

    Working with Todos:
    
        // Load store
        adapter, err := store.NewNanoStoreAdapter(path)
        defer adapter.Close()
        
        // Add todo
        todo, err := adapter.Add(text, parentID)
        
        // List todos
        todos, err := adapter.List(showAll)
        
        // Update todo
        err = adapter.Update(id, newText)

    Position Resolution:
    
        • Users provide position paths (1, 2.1, etc.)
        • Nanostore resolves to internal UUIDs
        • Operations use UUIDs internally
        • Results include position paths for display


Remember: Nanostore handles all the complexity of ID management and storage.
Focus on implementing clear, testable business logic that uses the adapter's
simple API.


Key Points:

    • CLI parses, business logic processes, nanostore stores
    • All IDs are managed by nanostore's canonical namespace system
    • SQLite provides reliable, transactional storage
    • Test everything, use testutil helpers
    • Clear separation of concerns throughout