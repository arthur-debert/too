                Testing Guide

This guide outlines testing practices, patterns, and tools for developing robust
and reliable tests. The nanostore system requires special attention to testing
due to its position path calculations and SQLite persistence.


1. Testing Philosophy

    Test Coverage Goals:
    
        • Unit tests for all business logic (80%+ coverage)
        • Integration tests for command workflows
        • Table-driven tests for comprehensive scenarios
        • Error path testing for robustness

    Test Organization:
    
        Convention: Tests live alongside code in *_test.go files
        
        Structure:
            pkg/too/
            ├── commands.go
            ├── commands_test.go
            └── testdata/
                └── sample.db

    Test Independence:
    
        • Each test must be runnable in isolation
        • No dependency on test execution order
        • Clean up all resources (especially temp files)
        • Use t.TempDir() for temporary directories

    Types of Tests:
    
        Unit Tests:
            Test individual functions with mocked dependencies.
            Focus on business logic, edge cases, and error handling.
        
        Integration Tests:
            Test complete command flows with real nanostore.
            Verify end-to-end functionality including persistence.
        
        CLI Tests:
            Test command parsing and flag handling.
            Only for testing the CLI layer and command routing.


2. Nanostore Testing Patterns

    Setting Up Test Stores:
    
        func TestAddCommand(t *testing.T) {
            // Create temporary test store
            adapter, dbPath := testutil.CreateTestStore(t)
            defer adapter.Close()
            
            // Add test data
            todo, err := adapter.Add("Test todo", nil)
            require.NoError(t, err)
            
            // Verify
            todos, err := adapter.List(false)
            assert.Len(t, todos, 1)
            assert.Equal(t, "Test todo", todos[0].Text)
        }

    Testing with Pre-populated Data:
    
        func TestCompleteCommand(t *testing.T) {
            // Create store with test data
            adapter, dbPath := testutil.CreatePopulatedStore(t)
            defer adapter.Close()
            
            // Execute command
            result, err := too.Complete("1", too.CompleteOptions{
                CollectionPath: dbPath,
            })
            
            // Verify
            assert.NoError(t, err)
            assert.Equal(t, models.StatusDone, result.Todo.GetStatus())
        }

    The testutil package provides nanostore-compatible helpers:
    
        // Create empty test store
        adapter, path := testutil.CreateTestStore(t)
        
        // Create store with default test data
        adapter, path := testutil.CreatePopulatedStore(t)
        
        // Create store with specific todos
        adapter, path := testutil.CreateStoreWithSpecs(t,
            testutil.TodoSpec{Text: "First", Complete: false},
            testutil.TodoSpec{Text: "Second", Complete: true},
            testutil.TodoSpec{Text: "Child", ParentPos: "1"},
        )

    Position Path Testing:
    
        // Nanostore-specific assertions
        func AssertTodoAtPosition(t *testing.T, todos []*models.Todo, position, text string) {
            for _, todo := range todos {
                if todo.PositionPath == position {
                    assert.Equal(t, text, todo.Text)
                    return
                }
            }
            t.Errorf("No todo found at position %s", position)
        }
        
        func AssertConsecutivePositions(t *testing.T, todos []*models.Todo) {
            pending := FilterPending(todos)
            for i, todo := range pending {
                expected := strconv.Itoa(i + 1)
                assert.Equal(t, expected, todo.PositionPath)
            }
        }


3. Table-Driven Testing

    Basic Pattern:
    
        func TestResolvePosition(t *testing.T) {
            tests := []struct {
                name     string
                input    string
                expected string
                wantErr  bool
            }{
                {"simple", "1", "uuid-1", false},
                {"nested", "1.2", "uuid-1-2", false},
                {"invalid", "x", "", true},
                {"empty", "", "", true},
            }
            
            for _, tt := range tests {
                t.Run(tt.name, func(t *testing.T) {
                    result, err := ResolvePosition(tt.input)
                    if tt.wantErr {
                        assert.Error(t, err)
                    } else {
                        assert.NoError(t, err)
                        assert.Equal(t, tt.expected, result)
                    }
                })
            }
        }

    Complex Scenarios:
    
        func TestCompleteMultiple(t *testing.T) {
            tests := []struct {
                name      string
                setup     []testutil.TodoSpec
                positions []string
                expected  int // expected done count
            }{
                {
                    name: "complete two of three",
                    setup: []testutil.TodoSpec{
                        {Text: "First"},
                        {Text: "Second"},
                        {Text: "Third"},
                    },
                    positions: []string{"1", "3"},
                    expected:  2,
                },
            }
            // Test implementation
        }


4. Testing Best Practices

    Arrange-Act-Assert Pattern:
    
        func TestTodoComplete(t *testing.T) {
            // ARRANGE: Set up test data
            adapter, path := testutil.CreateTestStore(t)
            defer adapter.Close()
            
            todo, _ := adapter.Add("Test todo", nil)
            
            // ACT: Execute operation
            err := adapter.Complete(todo.PositionPath)
            
            // ASSERT: Verify results
            assert.NoError(t, err)
            
            // Verify todo is in completed namespace
            todos, _ := adapter.List(true)
            completed := FilterCompleted(todos)
            assert.Len(t, completed, 1)
        }

    Test Helpers:
    
        Create focused helper functions for common assertions:
        
        func assertTodoCount(t *testing.T, adapter *store.NanoStoreAdapter, expected int) {
            t.Helper()
            todos, err := adapter.List(false)
            require.NoError(t, err)
            assert.Len(t, todos, expected)
        }

    Error Testing:
    
        Always test error conditions:
        
        func TestAddWithInvalidParent(t *testing.T) {
            adapter, _ := testutil.CreateTestStore(t)
            defer adapter.Close()
            
            invalidParent := "999"
            _, err := adapter.Add("Child", &invalidParent)
            
            assert.Error(t, err)
            assert.Contains(t, err.Error(), "parent not found")
        }


5. Integration Testing

    Command Integration Tests:
    
        Test complete command flows including persistence:
        
        func TestAddEditCompleteFlow(t *testing.T) {
            adapter, path := testutil.CreateTestStore(t)
            defer adapter.Close()
            
            // Add
            addResult, err := too.Add("Original", too.AddOptions{
                CollectionPath: path,
            })
            require.NoError(t, err)
            
            // Edit
            editResult, err := too.Modify("1", "Updated", too.ModifyOptions{
                CollectionPath: path,
            })
            require.NoError(t, err)
            assert.Equal(t, "Updated", editResult.Todo.Text)
            
            // Complete
            completeResult, err := too.Complete("1", too.CompleteOptions{
                CollectionPath: path,
            })
            require.NoError(t, err)
            assert.Equal(t, models.StatusDone, completeResult.Todo.GetStatus())
        }

    Cross-Command Testing:
    
        Verify interactions between commands:
        
        func TestMoveAffectsPositions(t *testing.T) {
            // Setup hierarchical todos
            // Move a todo
            // Verify all positions are recalculated correctly
        }


6. Performance Testing

    Benchmarking:
    
        func BenchmarkListWithManyTodos(b *testing.B) {
            adapter, _ := setupLargeDataset(b, 1000)
            defer adapter.Close()
            
            b.ResetTimer()
            for i := 0; i < b.N; i++ {
                _, err := adapter.List(true)
                if err != nil {
                    b.Fatal(err)
                }
            }
        }

    Load Testing:
    
        Test with realistic data volumes:
        • 1000+ todos
        • Deep nesting (5+ levels)
        • Many completed items


7. Test Utilities

    Common Test Patterns:
    
        // Filter helpers
        func FilterPending(todos []*models.Todo) []*models.Todo
        func FilterCompleted(todos []*models.Todo) []*models.Todo
        func FindByText(todos []*models.Todo, text string) *models.Todo
        
        // Assertion helpers
        func AssertTodoInList(t *testing.T, todos []*models.Todo, text string)
        func AssertTodoNotInList(t *testing.T, todos []*models.Todo, text string)
        func AssertTodoHasStatus(t *testing.T, todo *models.Todo, status models.Status)

    Test Data Builders:
    
        Use builder pattern for complex test data:
        
        type TodoBuilder struct {
            text     string
            status   models.Status
            parent   *string
            children []TodoBuilder
        }
        
        func (b TodoBuilder) Build(adapter *store.NanoStoreAdapter) (*models.Todo, error) {
            // Implementation
        }


8. Debugging Tests

    Verbose Output:
    
        Use -v flag for detailed test output:
        
            go test -v ./pkg/too/...

    Focused Testing:
    
        Run specific tests during development:
        
            go test -run TestComplete ./pkg/too
            go test -run TestComplete/multiple_items ./pkg/too

    Test Coverage:
    
        Generate coverage reports:
        
            scripts/test-with-cov
            go tool cover -html=coverage.out


Remember:

    Nanostore-Specific:
        • Position paths change after structural operations
        • Use UUIDs internally, position paths for display
        • SQLite handles concurrency - each test gets fresh DB
        
    Best Practices:
        • Test the behavior, not the implementation
        • Use testutil helpers for consistency
        • Clean up all resources
        • Test both success and failure paths


Common Pitfalls:

    • Assuming position paths remain stable after operations
    • Not cleaning up test databases
    • Testing nanostore internals instead of behavior
    • Forgetting to test error conditions


Key Testing Commands:

    • scripts/test - Run all tests with race detection
    • scripts/test-with-cov - Generate coverage report
    • go test -v ./... - Verbose test output
    • go test -bench=. - Run benchmarks