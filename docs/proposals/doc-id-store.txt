Title: Proposal for an Integrated Document and ID Store: microdoc

Summary:
      
      This document proposes a new library to replace the current pkg/idm and parts of
      pkg/too/store. The new library will be an integrated system, built on SQLite, that
      manages both the storage of documents (todos) and the dynamic generation of
      user-facing, contiguous IDs. This approach aims to drastically simplify the
      application's architecture, improve performance, and provide a more robust foundation
      for ID management.

1. Problem Statement:
      
      The current system for managing user-facing IDs suffers from several issues:

      1.1.  User Experience: Infinitely incrementing, non-contiguous IDs (e.g., 1434, 1436,
      ) are user-unfriendly for a CLI tool. Users expect lists to start at 1.

      1.2.  Architectural Complexity: The decoupling of the ID management (pkg/idm) from the
            document store (pkg/too/store) creates significant complexity. The application layer
            must act as an orchestrator, fetching data, filtering and sorting it in Go, and then
            passing the result to the ID manager to get the final view. This is inefficient and
            error-prone.

      1.3.  Imperative Logic: Much of the current logic for filtering, sorting, and grouping
            by dimensions (like status or parent) is handled imperatively in Go code. This is
            complex to maintain and less efficient than a declarative approach.

      1.4.  Hierarchical IDs: The combination of nested todos and different status dimensions
            (pending, completed) makes ID generation and resolution a non-trivial problem that
            the current system solves with high complexity.

2. Proposed Solution:
      
      The proposal is to create a new, self-contained library that encapsulates both
            storage and ID logic using an embedded SQLite database.

      This library will be the single source of truth for the application. The application
            will no longer fetch raw data and transform it. Instead, it will ask the library for
            a "view" of the data, and the library will return a list of items complete with the
            correct, user-facing IDs for that specific view.

      All complex logic for filtering, sorting, handling hierarchies, and generating
            contiguous IDs will be contained within the library, primarily implemented using
            declarative SQL queries.

3. Key Design Principles:

      3.1.  The ID is a Property of the View, Not the Data.

      The core principle is that the contiguous, user-facing integer ID (e.g., "1", "2",
            "c1") is not a persistent attribute of a document. It is a transient property
            calculated for a specific view of the data at a specific time. The only stable,
            persistent identifier for a document will be an internal UUID. This eliminates the
            need for complex "re-indexing" operations on every write. Writes (add, complete,
            edit) become simple INSERTs or UPDATEs. Reads (list, search) will generate the IDs on
            the fly.

      3.2.  Declarative Queries over Imperative Logic.

      We will leverage the power of SQL to handle data manipulation. The generation of
            contiguous IDs for different dimensions (partitions) is a perfect use case for SQL
            window functions, specifically `ROW_NUMBER() OVER (PARTITION BY ... ORDER BY ...)`. A
            single, declarative SQL query can replace the current multi-step imperative process
            of fetching, filtering, sorting, and generating IDs in Go.

      3.3.  Cohesion of Data and Logic.
      
      By placing the ID generation logic in the same component that manages the data, we
            create a highly cohesive system. The application's role is simplified to requesting a
            view and rendering the result, leading to cleaner, more maintainable code in the
            `cmd` layer.

4.Data Model / Schema:

      A single `documents` table in SQLite is sufficient to start.

            CREATE TABLE documents (
            uuid TEXT PRIMARY KEY,
            title TEXT NOT NULL,
            body TEXT,
            status TEXT NOT NULL DEFAULT 'pending',
            parent_uuid TEXT,
            created_at INTEGER NOT NULL,
            updated_at INTEGER NOT NULL,
            FOREIGN KEY (parent_uuid) REFERENCES documents(uuid)
            );

      - uuid: A unique, stable identifier (e.g., UUIDv4).
      - status: A string representing the primary dimension (e.g., 'pending', 'completed').
      - parent_uuid: A self-referencing foreign key to handle nesting. NULL for root items.
      - created_at: Unix timestamp for default sorting.

4. API Design Sketch:

      package docstore

      // The main library handle
      type Store struct {
      db *sql.DB
      }

      // Options for querying a view of the documents
      type ListOptions struct {
      FilterByStatus   []string
      FilterByParent   *string // UUID of the parent, nil for root
      FilterBySearch   string
      }

      // The object returned to the application, including the generated ID
      type ViewItem struct {
      UUID          string
      Title         string
      Status        string
      ParentUUID    *string
      UserFacingID  string // e.g., "1", "c1", "1.2", "1.c2"
      }

      // Primary read method
      func (s *Store) List(opts ListOptions) ([]ViewItem, error) {
      // Builds and executes a SQL query with ROW_NUMBER()
      // Formats the final UserFacingID string in Go
      }

      // Method to translate a user-facing ID to a stable UUID
      func (s *Store) ResolveUUID(userFacingID string) (string, error) {
      // Recursively resolves IDs like "1.2.c1" to a UUID
      }

      // Write methods
      func (s *Store) Add(title string, parentUUID *string) (string, error) {
      // Simple INSERT, returns the new UUID
      }

      func (s *Store) Update(uuid string, newTitle string, newBody string) error {
      // Simple UPDATE
      }

      func (s *Store) SetStatus(uuid string, status string) error {
      // Simple UPDATE to change the status
      }

5. ID Resolution Logic:

      To handle user input like `too complete 1.2`, the `ResolveUUID` method will be used.

      5.1.  The application passes the raw string "1.2" to `ResolveUUID`.
      5.2.  The method splits the string by ".".
      5.3.  It executes a query to find the item at the root with `user_facing_id = 1`. This
            involves a `SELECT` with the appropriate `ROW_NUMBER()` calculation for root items.
            It retrieves that item's UUID.
      5.4.  It then executes a second query to find the item with `user_facing_id = 2` whose
            `parent_uuid` matches the UUID from the previous step.
      5.5.  The final UUID is returned to the application, which can then use it to perform
            the `SetStatus` operation.

      Benefits:
      - Massively reduced complexity in the application's command layer.
      - Improved performance by offloading filtering and sorting to SQLite.
      - Enhanced data integrity via SQL constraints and transactions.
      - A single, cohesive, and more easily testable data management library.

      Potential Downsides:
      - The primary risk is introducing a CGO dependency via the standard
            `mattn/go-sqlite3` driver. This can add minor complexity to the cross-compilation
            build process, but this is a well-understood and solvable problem in the Go
            ecosystem.


6. implementation Planning

      1. Build locstore in isolation

      We'll use locstore/ to house the code and tests for the locstore 