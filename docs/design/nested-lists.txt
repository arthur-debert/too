                Nested Lists Design

This document outlines the design and behavior of the nested todo lists 
feature in too, including how it integrates with the nanostore system.


1. Problem Analysis

    A simple, flat list is insufficient for organizing related tasks. Users need
    the ability to break down larger items into smaller sub-tasks, creating a
    natural hierarchy. This feature adds this capability while maintaining the
    speed and convenience of the existing interface.

    The challenge is maintaining intuitive user-facing numbering while supporting
    arbitrary nesting depth and complex parent-child relationships.


2. Core Design: Data Model and Business Rules

    The implementation is built on the following principles:

    2.1 Data Model

        The Todo struct supports hierarchical relationships:

        - UID: A permanent, internal UUID (never changes)
        - ParentID: A string referencing the parent's UID. Empty string for root items
        - Text: The todo content  
        - Statuses: Map including completion status
        - PositionPath: Nanostore-calculated hierarchical position (e.g., "1.2.3")

        Nanostore manages the flat collection of todos with parent-child relationships
        expressed via ParentID references. This provides both flexibility and
        performance through SQLite storage.

    2.2 Business Rules: User-Centric Model

        The core principle is preserving user intent while providing intuitive
        hierarchical behavior.

        1. Explicit Status Control: Item status is explicitly set by the user
           and is not implicitly altered by actions on parents or children.

        2. Behavioral Propagation (Top-Down): When a parent is marked done,
           its children are effectively hidden from active views but retain
           their individual statuses.

        3. Auto-Completion (Bottom-Up): When all children of a parent are
           completed, the parent is automatically marked complete as a
           convenience feature.

        4. Position Path Calculation: Nanostore calculates position paths based on
           hierarchy (e.g., 1.2 for second child of first item).


3. Nanostore Integration for Hierarchical Structures

    Position Path System:
    
        Nanostore manages hierarchical position paths using dot notation:
        
        • Root items: Simple numbers (1, 2, 3)
        • Children: Parent path + position (1.1, 1.2, 2.1)
        • Deep nesting: Extended paths (1.2.3.4)

    Resolution Process:
    
        1. User provides hierarchical path (e.g., "1.2")
        2. Nanostore resolves path to UUID considering hierarchy
        3. Operations use UUID internally
        4. New paths calculated post-operation

    Namespace Behavior:
    
        • Pending items maintain consecutive numbering at each level
        • Completed items move to 'c' namespace within their parent
        • Structure preserved across status changes


4. User Interface and Commands

    4.1 Command Syntax
    
        Adding child todos:
            too add "Design database schema" to 3
            too add "Implement API endpoints" to 3

        The 'to' keyword specifies parent by position path.

    4.2 Display Representation
    
        Default display shows indented hierarchy:
        
            $ too list
            1. Backend refactoring
              1.1. Design database schema
              1.2. Implement API endpoints
            2. Write documentation
            3. Deploy to production

    4.3 Targeting Nested Items
    
        All commands work with hierarchical paths:
        
            too complete 1.2    # Complete "Implement API endpoints"
            too edit 1.1 "Update database design"
            too move 1.2 to 2  # Move item to different parent


5. Behavioral Examples

    5.1 Parent Completion Behavior
    
        When completing a parent with pending children:
        
            Initial state:
            1. Project X
              1.1. Research phase
              1.2. Implementation
            
            $ too complete 1
            
            Result (active view):
            [Empty - parent and children hidden]
            
            Result (--all view):
            1.c1. Project X [completed]
              1.c1.1. Research phase [pending but hidden]
              1.c1.2. Implementation [pending but hidden]

    5.2 Auto-Completion Behavior
    
        When all children are completed:
        
            Initial state:
            1. Release v2.0
              1.1. Fix bugs [pending]
              1.2. Update docs [pending]
            
            $ too complete 1.1
            $ too complete 1.2
            
            Result:
            Parent "Release v2.0" automatically marked complete

    5.3 Moving Items
    
        Items can be moved between parents:
        
            $ too move 2.3 to 1
            
            Moves item 2.3 to become a child of item 1,
            with position paths recalculated.


6. Technical Implementation

    Storage:
    
        • Nanostore handles all hierarchical relationships
        • Parent-child links via UUID references
        • Position paths calculated dynamically
        • Efficient queries via SQLite

    Operations:
    
        • Add with parent: Store parent UUID reference
        • Complete: Check children for auto-completion
        • Move: Update parent reference, recalculate paths
        • Delete: Option to cascade to children

    Performance:
    
        • Hierarchical queries optimized in SQL
        • Position paths cached within transaction
        • Bulk operations for cascade effects


7. Edge Cases and Constraints

    Depth Limits:
    
        • No hard limit on nesting depth
        • UI may truncate very deep paths for readability
        • Performance remains good to 10+ levels

    Circular References:
    
        • Prevented by nanostore validation
        • Move operations check for cycles
        • Clear error messages on attempts

    Large Hierarchies:
    
        • Tested with 1000+ items in hierarchy
        • Position calculation remains efficient
        • Display may paginate for usability


Summary:

    The nested lists system leverages nanostore to provide intuitive
    hierarchical organization while maintaining the simplicity and speed
    that makes too effective. The canonical namespace pattern extends
    naturally to nested structures, ensuring consistent behavior across
    all operations.