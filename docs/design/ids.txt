                ID Design

This document explains how too manages identifiers, providing both intuitive 
user-facing IDs and stable internal references through the nanostore library.


1. The Problem

    Command-line todo managers face a fundamental challenge with identifiers:

    User Expectations:
    
        • Simple numeric IDs for easy reference (1, 2, 3)
        • Consecutive numbering for active todos
        • IDs that remain consistent during a session
        • Intuitive hierarchical paths (1.2 for subtasks)

    Technical Requirements:
    
        • Unique identifiers that survive reordering
        • Stable references for programmatic access
        • Support for hierarchical relationships
        • Efficient lookups and updates

    The Core Conflict:
    
        Users want "complete 2" to always target the second visible todo,
        but this breaks when todo 1 is completed and todo 3 becomes the new
        todo 2. This creates confusion when multiple commands reference todos
        by position.


2. The too Solution: Nanostore Integration

    too solves this problem using nanostore, which provides:

    Internal UUIDs:
    
        • Every todo has a permanent UUID
        • Never exposed to users
        • Survives all operations
        • Used for all internal operations

    User-Facing IDs:
    
        • Calculated dynamically by nanostore
        • Based on canonical namespace pattern
        • Simple numbers for pending items (1, 2, 3)
        • Special namespace for completed items (1.c1, 1.c2)

    Semi-Stable Behavior:
    
        • IDs remain stable within their namespace
        • Pending items renumber to stay consecutive
        • Completed items keep their position in 'c' namespace
        • Hierarchical paths supported (1.2, 1.2.3)


3. Canonical Namespace Pattern

    Nanostore implements different namespaces for different states:

    Pending Namespace (default):
    
        • Consecutive numbering starting from 1
        • Gaps are filled when items complete
        • Always shows clean 1, 2, 3... sequence
        • Most intuitive for daily use

    Completed Namespace ('c' prefix):
    
        • Items move here when marked done
        • Preserves completion order
        • Format: parent.c1, parent.c2, etc.
        • Keeps completed items accessible

    Example Flow:
    
        Initial:        After completing 2:    After completing 1:
        1. Buy milk     1. Buy milk           1. Pack bags (was 3)
        2. Pack car     2. Pack bags          1.c1. Buy milk
        3. Pack bags    2.c1. Pack car        1.c2. Pack car


4. Implementation Details

    Storage Layer:
    
        • SQLite database via nanostore
        • UUIDs as primary keys
        • Position paths calculated via SQL window functions
        • Efficient bulk operations

    Resolution Process:
    
        1. User provides position path (e.g., "2")
        2. Nanostore queries current state
        3. Resolves to UUID based on active namespace
        4. Operation uses UUID internally
        5. New position paths calculated for display

    Hierarchical Support:
    
        • Dot notation for nested items (1.2.3)
        • Each level maintains its own numbering
        • Parent-child relationships via UUID references
        • Paths recalculated on structural changes


5. Benefits of This Approach

    For Users:
    
        • Simple numeric IDs for common operations
        • Predictable consecutive numbering
        • Completed items don't disrupt active list
        • Natural hierarchical paths

    For Developers:
    
        • Clear separation of display vs storage
        • Reliable internal references
        • Atomic operations via SQLite
        • Extensible namespace system

    For Performance:
    
        • Efficient SQL-based calculations
        • Bulk operations supported
        • No need to renumber on disk
        • Fast lookups via indexes


6. Practical Examples

    Daily Use Pattern:
    
        $ too add "Buy groceries"
        $ too add "Clean house"  
        $ too add "Write report"
        $ too list
        1. Buy groceries
        2. Clean house
        3. Write report
        
        $ too complete 2
        $ too list
        1. Buy groceries
        2. Write report    # Renumbered from 3
        
        $ too list --all
        1. Buy groceries
        1.c1. Clean house  # In completed namespace
        2. Write report

    Hierarchical Pattern:
    
        $ too add "Project Alpha"
        $ too add "Design phase" to 1
        $ too add "Implementation" to 1
        $ too list
        1. Project Alpha
          1.1. Design phase
          1.2. Implementation

    Multiple Operations:
    
        When completing multiple items, resolve all IDs first:
        
        $ too complete 1 3  # Resolves both before any changes
        
        This prevents issues with shifting positions during the operation.


7. Edge Cases and Limitations

    Known Behaviors:
    
        • IDs change after structural operations
        • Completing items in order may affect subsequent IDs
        • Deep hierarchies can have long paths (1.2.3.4.5)

    Best Practices:
    
        • Complete items one at a time for clarity
        • Use latest list output for reference
        • Script operations should use stable references

    Future Considerations:
    
        • Additional namespaces could be added
        • Alternative ID schemes possible
        • Performance optimized for typical use


Summary:

    Nanostore provides too with a sophisticated ID system that balances
    user convenience with technical requirements. The canonical namespace
    pattern ensures intuitive daily use while maintaining data integrity
    and enabling powerful operations.